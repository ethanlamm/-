#### Javacript

##### 一、内存管理

- 栈内存（Stack）、堆内存（Heap）

|        |       基本类型       |               引用类型               |
| :----: | :------------------: | :----------------------------------: |
|   值   |        不可变        |                 可变                 |
|  比较  |       值的比较       |              引用的比较              |
| 栈内存 | 变量标识符和变量的值 | 变量标识符和指向堆内存中该对象的指针 |
| 堆内存 |          ——          |            对象的内容(值)            |

- 新生代、老生代
- 查看内存

```
1.浏览器端：window.performance.memory
2.node端：process.memoryUsage()
```

- 变量的回收

```
1.判断何时可回收?
■ 全局变量：代码执行完毕后，才回收
■ 局部变量：失去引用后，回收

2.回收优化
■ 尽量不要定义全局变量，定义了及时手动释放(全局变量=null/undefined)
■ 注意闭包
```

- 回收机制

```
1.浏览器端：变量回收的自动的，无法手动触发
2.node端：
■ 可手动触发：global.gc
■ 可设置内存：node -max-old-space-size=1000 text.js（表示运行test.js文件时，老生代最大内存为1000Mb）
```

##### 二、代码性能指标

1.健壮性：抗击风险（如Bug等）的能力

2.可读性：

```
1）常量全大写
■ const PIE=3.14.115926
2）类名首字母大写 使用大驼峰写法，普通变量和方法（小驼峰）
■ class MyClass {}
■ function addFn () {}
3）局部变量下划线开头
■ let _arg=xxx
4）遵循语义化
```

3.可复用性

```
■ 桥接模式
■ 享元模式
■ 函数式编程
■ 低耦合，高内聚
```

4.可扩展性

```
■ 留出扩展接口
■ 模块低耦合，高内聚
■ 良好的模块组织
■ 良好的扩展方案
```

##### 三、函数式编程

1.提高复用性和可扩展性

2.利于Tree-shaking：Tree-shaking的本质是通过文档流的引入判断是否使用了某个方法

3.compose函数和pipe函数

4.高阶函数：一个函数的参数是另一个函数，则该函数是高阶函数

```
foreach、map、filter、reduce、find
```

5.函数柯里化

##### 四、异步

