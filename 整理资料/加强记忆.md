##### 数组的方法

1.操作
·增：push unshift splice `concat`
·删：pop shift splice `slice`
·改：splice
·查：indexOf/lastIndexOf includes find 
2.排序
reverse sort
3.转换
join
4.迭代（都不改变原数组）
some every forEach filter map

判断是否为数组
let arr=[1,2,3]
1）arr instanceof Array
2）arr.constructor === Array
3）Object.prototype.toString.call(arr) === '[object Array]'
4）Array.isArray(arr)  最推荐
注意 typeof arr  // object

---------------------------------

##### 字符串的方法

1.操作 **所有操作均是先生成一个副本，再对副本进行操作**
·增：`+` `${}` `concat`
·删：`slice` `substring(startIndex,endIndex)` `substr(startIndex,count) `
·改：`trim trimLeft trimRight` `padStart padEnd` `toLowerCase toUpperCase` `repeat`
·查：`indexOf lastIndexOf` `startsWith endsWith` `charAt(index)` `includes`
2.转换
splict
3.匹配
match：str.match(Reg) 返回 数组/null
search：str.search(Reg) 返回 index/-1
replace：str.replace(Reg,replacedEle) 返回 新字符串/副本字符串

----------

类型转换
1.显式转换
转为数字型：Number(xx) parseInt(xx) parseFloat(xx)
转为字符串：String(xx) xx.toString() num.toFixed() num.toLocaleString()
转为布尔值：Boolean(xx)
2.隐式转换
+：拼接字符串，转为字符串
其他：转换为数值

类型判断
1）typeof：对基本类型能判断(除null判断为object)，
对引用数据类型判断为object(除function判断为function)
2）instanceof：不能正确判断基本类型，可准确判断引用数据类型
3）Object.prototype.toString(xx) | Object.prototype.toString.call(xx)：
准确判断基本类型和引用数据类型

---

不冒泡的事件：scroll	  blur/focus  Media事件  mouseleave/mouseenter

-------------------------------------------------------------------
##### 缓存一个组件

`keep-alive`可以设置以下`props`属性：

- `include` - 字符串或正则表达式。只有名称匹配的组件会被缓存
- `exclude` - 字符串或正则表达式。任何名称匹配的组件都不会被缓存
- `max` - 数字。最多可以缓存多少组件实例

```vue
<!-- 1.缓存一个： include="组件名" -->
<!-- 2.缓存多个： :include="['组件名1','组件名2'....]" -->
<keep-alive include="News">
  <router-view></router-view>
</keep-alive>

<!-- 以英文逗号分隔的字符串 -->
<KeepAlive include="a,b">
  <component :is="view" />
</KeepAlive>

<!-- 正则表达式 (需使用 `v-bind`) -->
<KeepAlive :include="/a|b/">
  <component :is="view" />
</KeepAlive>

<!-- 数组 (需使用 `v-bind`) -->
<KeepAlive :include="['a', 'b']">
  <component :is="view" />
</KeepAlive>

<!-- 最大缓存实例数 (需使用 `v-bind`) -->
<KeepAlive :max="10">
  <component :is="activeComponent" />
</KeepAlive>
```

重点1：组件名首先匹配组件自身的name；其次匹配组件注册时的name；匿名组件不匹配

重点2：缓存的组件会多出2个生命周期（`activated`与`deactivated`）：

- 首次进入组件时：`beforeRouteEnter` > `beforeCreate` > `created`> `mounted` > `activated` > ... ... > `beforeRouteLeave` > `deactivated`
- 再次进入组件时：`beforeRouteEnter` >`activated` > ... ... > `beforeRouteLeave` > `deactivated`
- 由于再次进入不会重新挂载`mounted`，若要求缓存组件并且每次进入都重新请求数据，那么请求数据的方法可写在**activated**生命周期中

-----------------------------------------------------------------

##### vue常用修饰符

表单：v-model.lazy	v-model.trim	v-model.number

事件：stop(阻止冒泡)	prevent(阻止事件默认行为)	once(只触发一次)	native(原生) @scroll.passive(移动端，相当于给scroll事件整了一个lazy修饰符)	

v-bind：[sync](https://vue3js.cn/interview/vue/modifier.html#二、修饰符的作用)(双向绑定)

--------

##### 过滤器

- vue2.x

`main.js` ---全局过滤器

```js
Vue.filter('decimal', function (value) {
  // console.log(this);
  return Number(value) && Number(value).toFixed(2)
})
```

`demo.vue` ---本地过滤器

```js
filters:{
    decimal:function(value){
        return Number(value) && Number(value).toFixed(2)
    }
}
```

使用

```vue
<template>
	<div>{{ num | decimal}}</div>	// |：管道符
</template>
```



- vue3.x
- 没有过滤器；实质是一个函数

```vue
<template>
	<div>{{ priceFormat(price) }}</div>
</template>
<scrpit setup>
	const priceFormat=(value)=>{
    	// toFixed:需要先转换成数字类型
      	return parseFloat(value).toFixed(2)
    }
</scrpit>
```

---

##### var、let和const

- 变量提升(var)
- 块级作用域(let const)
- 暂时性死区(let const)
- 重复声明(var)
- 修改值(var let)

---

##### [ES6 数组扩展](https://www.runoob.com/w3cnote/es6-array.html)

- 扩展运算符

- `Array.from`：将类数组对象（`arguments`对象、DOM NodeList对象）或可迭代对象(set、map、字符串)转为数组

- `Array.of`：将一组值转为数组

  ```js
  console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4]
  ```

- `find、findIndex`

- `includes`

- `flat`、`flatMap`：数组扁平化，返回一个新数组，对原数据没有影响

```js
[1, 2, [3, [4, 5]]].flat()
// [1, 2, 3, [4, 5]]  flat()默认只会“拉平”一层

[1, 2, [3, [4, 5]]].flat(2)
// [1, 2, 3, 4, 5]

[2, 3, 4].flatMap((x) => [x, x * 2])
// [2, 4, 3, 6, 4, 8]
// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
```

- `keys、values`
- `fill`：使用给定值，填充一个数组
- `copyWithin`：将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组
- `sort`：ES6将`sort()`默认设置为稳定的排序算法

---

##### [ES6 对象扩展](https://www.runoob.com/w3cnote/es6-object.html)

- 扩展运算符

- 属性简写

- 方法名简写

- 属性名表达式

- `Object.assign`：合并对象

- `Object.is(valueA,valueB)`：类似`===`，判断两个值是否严格相等

```js
// 不同
+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
```

- `Object.keys、Object.values`
- `Object.setPrototypeOf(object,target)`：设置一个对象的原型对象
- `Object.getPrototypeOf(object)`：读取一个对象的原型对象

---

##### [ES6 函数扩展](https://www.runoob.com/w3cnote/es6-function.html)

- 默认参数
- 不定参数：`...变量名`，并且要求放到参数组最后，以数组形式接收
- `name`：返回函数名
- `length`：返回没有设置默认值的参数的个数
- 箭头函数：没有`this`、`arguments`、不可以作为构造函数(不可以 `new`)

---

##### [ES6 Set 与 Map](https://www.runoob.com/w3cnote/es6-map-set.html)

- 共同点：集合、字典都可以存储不重复的值，都通过`new`关键字得到
- 不同点：集合`Set`是以[值，值]的形式存储元素，字典`Map`是以[键，值]的形式存储



**Set(集合)：存储单列数据的集合，无顺序，不允许重复**

```js
const s = new Set() 
```

- 操作(增删改查)

```js
// 增
s.add(1).add(2).add(2); // 2只被添加了一次

// 删
s.delete(1)

// 查
s.has(2)	// true

// 清空
s.clear()
```

- 遍历：`s.keys()`、`s.values()`、`s.entries()`、`s.forEach()`

- 去重：扩展运算符 + Set结构

```js
// 数组
let arr = [3, 5, 2, 2, 5, 5];
let unique = [...new Set(arr)]; // [3, 5, 2]

// 字符串
let str = "352255";
let unique = [...new Set(str)].join(""); // "352"
```



**Map(字典)：存储键值对的双列数据的集合，无顺序，键不允许重复，值允许**

```js
const m = new Map()
```

- 操作(增删改查)

```js
// 增 set方法
m.set('key1',1)
m.set('key2',2)
m.set('key2',3)

// 删 delete方法
m.delete('key2')

// 查
m.size	// 2	size属性：返回Map结构的成员总数

m.has('key2')	// false	has方法：查询某个键是否在Map结构中

m.get('key2')	// undefined	get方法：返回key对应的值,找不到返回undefined

// 清空
m.clear()
```

- 遍历：`m.keys()`、`m.values()`、`m.entries()`、`m.forEach()`



**List(列表)--Java：有顺序，允许重复**

- 操作(增删改查)

```java
// 增 add
List<String> person=new ArrayList<>();
person.add("jackie");   //索引为0  //.add(e)
person.add("peter");    //索引为1
person.add("annie");    //索引为2
person.add("martin");   //索引为3
person.add("marry");    //索引为4

// 删 remove(index/element)
person.remove(3);   	//.remove(index)
person.remove("marry");     //.remove(Object o)

// 查
person.get(1)	// peter

person.contains('martin')	// true

person.indexOf('jackie')	// 0
    
    
// 改 set(index, element)	add(index, element)
String a="白龙马", b="沙和尚", c="八戒", d="唐僧", e="悟空";
List<String> people=new ArrayList<>();
people.add(a);
people.add(b);
people.add(c);
people.set(0, d);   //将d唐僧放到list中索引为0的位置，替换a白龙马
people.add(1, e);   //将e悟空放到list中索引为1的位置,原来位置的b沙和尚后移一位
```



---

##### [ES6 Promise](https://vue3js.cn/interview/es6/promise.html#一、介绍)

Promise是异步编程的一种解决方案

Promise解决的问题：

- **消灭嵌套调用**：通过 Promise 的链式调用可以解决；

- **合并多个任务的请求结果**：使用 Promise.all 获取合并多个任务的错误处理。



1.状态

`promise`对象仅有三种状态

- `pending`（进行中）
- `fulfilled`（已成功）
- `rejected`（已失败）

2.特点

- `promise`对象的状态只受异步操作结果影响，`resolve`(`pending`=>`fulfilled`)、`reject`(`pending`=>`rejected`)

- 一旦状态发生改变，则状态不会再变

```js
const p1 = new Promise(function(resolve,reject){
    resolve('success1');	// 状态改变
    resolve('success2');
}); 
const p2 = new Promise(function(resolve,reject){  
    resolve('success3'); 	// 状态改变
    reject('reject');
});
p1.then(function(value){  
    console.log(value); // success1
});
p2.then(function(value){ 
    console.log(value); // success3
});
```

3.`Promise`实例的方法

`Promise`对象是一个构造函数，`Promise`实例通过`new`关键字得到

```js
const promise = new Promise((resolve,reject)=>{})
```

`Promise`实例的方法(3种)

- `then()`：1）只要状态发生改变，则执行then回调；

  2）then回调接收两个函数作为参数：第一个参数是`fulfilled`状态的回调函数，第二个参数是`rejected`状态的回调函数

- `catch()`：1）是`.then(null, rejection)`或`.then(undefined, rejection)`的别名，用于指定发生错误时的回调函数；

  2）只有当`then`回调没有第二个参数且`Promise`实例的状态为`rejected`时才会执行，即，使用`catch`方法代替`then()`第二个参数

  3）`Promise`对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止

- `finally()`：不管 Promise 对象最后状态如何，都会执行的操作

4.[`Promise`对象的方法)](https://vue3js.cn/interview/es6/promise.html#二、用法)

- `resolve()`
- `reject()`
- `all()`
- `race()`

5.promise的缺点

- 无法取消 Promise，一旦新建它就会立即执行，无法中途取消
- 如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部
- 当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始 还是即将完成）

6.手写Promise(只实现基本功能，then 的链式调用和值穿透特性未实现)

```js
const PENDING = 'PENDING';
const FULFILLED = 'FULFILLED';
const REJECTED = 'REJECTED';

class Promise {
  constructor(executor) {
    this.status = PENDING;
    this.value = undefined;	// 存放成功状态的值，默认为 undefined
    this.reason = undefined;// 存放失败状态的值，默认为 undefined
    // 存放成功的回调
    this.onResolvedCallbacks = [];
    // 存放失败的回调
    this.onRejectedCallbacks= [];

    let resolve = (value) => {
      if(this.status ===  PENDING) {
        this.status = FULFILLED;
        this.value = value;
        // 依次将对应的函数执行
        this.onResolvedCallbacks.forEach(fn=>fn());
      }
    } 

    let reject = (reason) => {
      if(this.status ===  PENDING) {
        this.status = REJECTED;
        this.reason = reason;
        // 依次将对应的函数执行
        this.onRejectedCallbacks.forEach(fn=>fn());
      }
    }

    try {
      executor(resolve,reject)
    } catch (error) {
      reject(error)
    }
  }

  then(onFulfilled, onRejected) {
    if (this.status === FULFILLED) {
      onFulfilled(this.value)
    }

    if (this.status === REJECTED) {
      onRejected(this.reason)
    }

    if (this.status === PENDING) {
      // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行
      this.onResolvedCallbacks.push(() => {
        onFulfilled(this.value)
      });

      // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行
      this.onRejectedCallbacks.push(()=> {
        onRejected(this.reason);
      })
    }
  }
}

// 测试
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('成功');
  },1000);
}).then(
  (data) => {
    console.log('success', data)
  },
  (err) => {
    console.log('faild', err)
  }
)
```

![image-20221102152344039](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20230106170649944.png)

---

##### [ES6 Iterator(迭代器)](https://www.bookstack.cn/read/es6-3rd/spilt.1.docs-iterator.md)

1.定义：迭代器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。

2.作用：

一是为各种数据结构，提供一个统一的、简便的访问接口；

二是使得数据结构的成员能够按某种次序排列；

三是 ES6 创造了一种新的遍历命令`for...of`循环，Iterator 接口主要供`for...of`消费。

3.默认 Iterator 接口

ES6 规定，默认的 Iterator 接口部署在数据结构的`Symbol.iterator`属性，或者说，一个数据结构只要具有`Symbol.iterator`属性，就可以认为是“可遍历的”（iterable）。

`Symbol.iterator`属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器对象。

遍历器对象的根本特征就是具有`next`方法。每次调用`next`方法，都会返回一个代表当前成员的信息对象，具有`value`和`done`两个属性

4.原生具备 Iterator 接口的数据结构

```
Array、Map、Set、String、函数的arguments对象、TypedArray、NodeList对象
```

对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。

5.调用默认Iterator 接口的场景

- `for...of`
- 解构赋值：`let [a,b]=[1,2]`
- 扩展运算符
- yield*
- Array.from
- 创建集合`new Set()`、创建字典`new Map()`
- Promise.all()、Promise.race()

6.遍历器对象的`return()`方法

作用：用于提前**关闭**迭代逻辑。**该方法是可选的**

return()方法必须返回一个有效的IteratorResult对象。简单情况下，可以只返回{ done: true }

触发return方法的情况：

- for-of 循环通过 break、continue、return 或 throw 提前退出
- 解构操作并未消费所有值

注意：

- 因为 return()方法是可选的，所以**并非所有迭代器都是可关闭的**。
- 要知道某个迭代器是否可关闭，可以测试这个迭代器实例的 return 属性是不是函数对象。不过，仅仅给一个不可关闭的迭代器增加这 个方法**并不能**让它变成可关闭的
- 如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭代。比如，**数组**的迭代器就是不能关
  闭的

```
let a = [1, 2, 3, 4, 5]; 
let iter = a[Symbol.iterator]();
for (let i of iter) { 
	console.log(i); 
	if (i > 2) { 
		break
	}
}
// 1 
// 2 
// 3
for (let i of iter) { 
	console.log(i);
}
// 4 
// 5
```

---

##### [ES6 Generator(生成器)](https://www.bookstack.cn/read/es6-3rd/spilt.1.docs-generator.md)

1.理解

Generator 函数是 ES6 提供的一种异步编程解决方案。

Generator 函数是一个状态机，封装了多个内部状态

执行 Generator 函数会返回一个生成器对象，生成器对象也实现了 Iterator 接口，因此具有 next() 方法。调用next()方法会让生成器 开始或恢复执行

2.特征

- `function`关键字与函数名之间有一个星号`*`，一般`*`紧跟在`function`关键字后面
- 函数体内部使用`yield`表达式，定义不同的内部状态（`yield`表达式只能用在 Generator 函数里面使用）
- Generator 函数执行后，返回一个生成器对象。该对象本身也具有`Symbol.iterator`属性，执行后返回自身
- 注意：箭头函数不能用来定义生成器函数

3.生成器的方法

1）return() 方法：用于关闭生成器。一旦进入关闭状态，就无法恢复。提供给 return() 方法的值，就是终止迭代器对象value的值

```js
function* generatorFn() { 
	for (const x of [1, 2, 3]) { 
		yield x;
	} 
}
const g = generatorFn(); 
console.log(g);		// generatorFn {<suspended>}
console.log(g.return(4)); 	// { done: true, value: 4 } 
console.log(g);		// generatorFn {<closed>}
```

2）throw() 方法

4.生成器和`for...of`

`for...of`循环可以自动遍历 Generator 函数运行时生成的生成器对象，且此时不再需要调用`next`方法。

需要注意的是：一旦`next`方法的返回对象的`done`属性为`true`，`for...of`循环就会中止，且不包含该返回对象

```js
function* foo() {
  yield 1;
  yield 2;
  yield 3;
  return 4;
}
for (let v of foo()) {
  console.log(v);
}
// 1 2 3
// 没有 4
```

除了**for...of循环**以外，**扩展运算符**、**解构赋值**和**Array.from**方法内部调用的，都是遍历器接口

5.应用——封装异步任务

Generator 函数可以用来封装异步任务的原因

- 可以暂停执行和恢复执行（根本原因）
- 函数体内外的数据交换：`next`返回值的 value 属性，是 Generator 函数向外输出数据；`next`方法还可以接受参数，向 Generator 函数体内输入数据。
- 错误处理机制

6.[Thunk 函数](https://www.bookstack.cn/read/es6-3rd/spilt.4.docs-generator-async.md)

1）定义

- 广义：是“传名调用”的一种实现策略，用来替换某个表达式

- 在 Javascript 中：是一个只接受回调函数作为参数的单参数函数。任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式

2）作用：自动执行 Generator 函数，做Generator 函数的流程管理

7.[co 模块](https://www.bookstack.cn/read/es6-3rd/spilt.5.docs-generator-async.md)



---

##### ES6 Proxy

代理：是对目标对象的抽象。代理可以定义包含捕获器(trap)的处理程序对象，而这些捕获器可以拦截绝大部分 JavaScript 的基本操作和方法

应用场景：跟踪属性访问、隐藏属性、阻止修改或删除属性、函数参数验证、构造函数参数验证、数据绑定与可观察对象

```js
let target={name:'zs',age:18}
let handler={
	get(target,property,receiver){
		return Reflect.set(...arguments)
	}
	set(target,property,value,receiver){
		return Reflect.set(...arguments)
	}
	has(target,property){
		return Reflect.has(...arguments)
	}
}
let proxy=new Proxy(target,handler)
proxy.name	// 'zs'
proxy.age=20
proxy.age	// 20
'name' in proxy	// true

// 注意：只有在代理对象上执行某些操作，才会触发捕获器
```



---

##### [ES6 Decorator (装饰器)](https://vue3js.cn/interview/es6/decorator.html#一、介绍)

实质：是一个函数，用来扩展类属性和类方法

优点：

- 代码可读性变强，装饰器命名相当于一个注释
- 在不改变原有代码情况下，对原来功能进行扩展



**1.类的装饰**

当对类本身进行装饰的时候，能够接受一个参数，即类本身

```js
function decorator (target){
    target.isTestable=true
}

@decorator
class A {}

// 等价于
A = decorator(A) || A

A.isTestable	// true
```



**2.类属性的装饰**

装饰器接受三个参数：

- `target`：类的原型对象
- `name`：需要装饰的属性名
- `descriptor`：装饰属性名的描述对象



首先定义一个`readonly`装饰器

```js
function readonly(target, name, descriptor){
  descriptor.writable = false; // 将可写属性设为false
  return descriptor;	// 必须返回
}
```

使用`readonly`装饰类的`name`方法

```js
class Person {
  @readonly
  name() { return `${this.first} ${this.last}` }
}
```

相当于以下调用

```js
readonly(Person.prototype, 'name', descriptor);
```

---

##### [ES6 Module (模块)](https://vue3js.cn/interview/es6/module.html#一、介绍)

模块化的优点

- 防止命名冲突、不会污染全局作用域
- 代码复用
- 高维护性



ES6之前：CommonJs、AMD、CMD

```js
// CommonJs
const $ = require('jquery')
const fs = require('fs');
```



ES6 Module 特点：

1）静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量

2）同一模块中，`export`、`import`可以有多个，`export default`有且仅有一个

- `export`：用于规定模块的对外接口
- `import`：用于导入其他模块提供的功能
- `as`：别名
- 动态加载：将`import()`作为函数调用
- 复合写法

```js
export { foo, bar } from 'my_module';

// 可以简单理解为
import { foo, bar } from 'my_module';
export { foo, bar };
```

---

##### HTML页面标签说明

![image-20220822220627443](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20220822220627443.png)

---

##### 闭包

- 闭包是调用私有属性的接口

- 闭包就是外部函数引用另一函数私有变量的一种方式，将内部嵌套函数变成外部可调用

- 闭包会持有父方法的局部变量并且不会随父方法销毁而销毁

```js
var add = (function () {
    var counter = 0;
    return function () {return counter += 1;}
})();
 
add();	// 1
add();	// 2
add();	// 3
```

优缺点：

- 优点(作用)：就是跨作用域访问变量！让函数外部也可以访问到函数内的变量

- 缺点：内存消耗大，IE容易造成内存泄露

---

##### 防抖与节流

**简单防抖**

```html
<body>
    <button>触发事件--防抖</button>
    <script>
        let debounce = (function () {
            let timeout;

            return function (fn, wait) {
                // let context = this; // 保存this指向
                // let args = arguments; // 拿到event对象
                clearTimeout(timeout)
                timeout = setTimeout(() => {
                    // fn.apply(context, args)
                    fn()
                }, wait);
            }
        })()

        const myfn = (val) => {
            console.log('防抖', val);
        }
        const button = document.querySelector('button')
        button.addEventListener('click', () => {
            debounce(() => myfn(10), 2000)
        })
    </script>
</body>
```

防抖在连续的事件，只需触发最后一次回调的场景有：

- 搜索框搜索输入。只需用户最后一次输入完，再发送请求
- 手机号、邮箱输入，输入完毕后验证
- 窗口大小`resize`。只需窗口调整完成后，计算窗口大小。防止重复渲染。



**简单节流**

```html
<body>
    <button>触发事件--节流</button>
    <script>
        let throttle = (function () {
            let timer
            return function (fn, interval) {
                if (!timer) {
                    timer = setTimeout(() => {
                        fn()
                        timer = null
                    }, interval);
                }
            }
        })()
        const myfn = (val) => {
            console.log('节流', val);
        }
        const button = document.querySelector('button')
        button.addEventListener('click', () => {
            throttle(() => myfn(10), 2000)
        })
    </script>
</body>
```

节流在间隔一段时间执行一次回调的场景有：

- 触底刷新、加载更多：多次触底刷新，在一段时间内只发一次请求

---

##### 事件循环(event loop)

定义：

在`JavaScript`中，所有任务可分为同步任务和异步任务，异步任务又分为微任务和宏任务。

运行流程：同步任务在主线程中执行，异步任务放在任务队列中；当主线程的任务执行完毕，会读取任务队列的事件，推入主线程再执行。上述过程不断重复就是事件循环

**微任务**的执行时机：主函数执行结束之后、当前宏任务结束之前

**常见的微任务有：**

- Promise.then
- process.nextTick（Node.js)
- MutaionObserver
- Object.observe（已废弃；Proxy 对象替代）

**常见的宏任务有：**

- setTimeout/setInterval
- setImmediate、I/O（Node.js）

- script (可以理解为外层同步代码)

- UI rendering/UI事件

- postMessage、MessageChannel


---

##### [H5新特性：十个新特性](https://www.cnblogs.com/jane-panyiyun/p/13092297.html)

1.语义化标签：`header`、`footer`、`section`、`nav`、`aside`、`article`；提升页面的阅读性(结构性增强)，更有利于SEO

![image-20230106170649944](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221102160353350.png)

2.增强型表单：

- `input`标签的`type`属性新增：color(取色器)、email、url、number、tel、search、range、date、week、month
- 新表单元素：`datalist`数据列表、`progress`进度条、`meter`刻度尺、`output`输出
- 新表单属性：`autocomplete`自动补全、`placeholder`占位符、`autofocus`自动获得焦点、`multiple`是否允许多个输入值、`required`必填项、`minlength`最小长度、`min/max`最大/小值、`step`限定输入的数字的步长、`pattern`指定一个正则表达式

3.新增媒体元素：`audio`音频、`video`视频；

4.`canvas`绘图

5.SVG绘图

6.`geolotion`地理定位

7.拖放API

8.Web Worker

9.Web Storage：`sessionStorage`、`localStorage`

10.WebSocket

---

##### DOM操作方法

1.创建：createElement、createTextNode、createAttribute

2.获取：querySelector、 querySelectorAll、getElementById、getElementsByClassName、getElementsByTagName、document.documentElement、document.body

3.更新： innerHTML、 innerText、textContent、style

4.添加：innerHTML、appendChild、 insertBefore

5.删除：拿到要删除的节点=>parentElement=>removeChild

---

##### innerHTNL的漏洞(XSS攻击)与安防

原理：textContent对标签元素不解析，直接转换为字符串；

innerHTML对已转化成字符串的内容直接输出，不会反转

```html
<body>
    <div id="root"></div>
    <div id="id">111<span>2222</span>11</div>
    <script>
        const div = document.getElementById('root')
        const div1 = document.getElementById('id')
        // console.log(div1.textContent);
        // console.log(div1.innerHTML);
        const sanitizeHTML = function (content) {
            // 创建一个div
            let temp = document.createElement("div");
            // textContent：将用户输入的内容content转换成字符串
            temp.textContent = content;
            // innerHTML：对字符串不再解析，直接返回字符串
            return temp.innerHTML;
        };
        div.innerHTML = "<h3>" + sanitizeHTML("<img src=x onerror=\"alert('XSS Attack')\">") + "</h3>"
    </script>
</body>
```



**v-html的漏洞(XSS攻击)与安防---vue项目**

1.安装[xss](https://www.npmjs.com/package/xss)

```sh
npm install xss
```

2.引入`xss`并进行配置

新增`xss.js`文件

```js
import xss from 'xss'
// 使用默认配置加自定义配置
const css = xss.getDefaultCSSWhiteList()
const tag = xss.getDefaultWhiteList()
// 例如
// css.background = false // css style中禁止使用background 属性
// tag.a = ['style'] // 只允许a标签中存在 style属性

// 自定义配置
const options = {
  stripIgnoreTagBody: true, // 不在白名单中的标签以及标签里面的内容直接删除
  whiteList: tag,
  css: {
    whiteList: css
  }
}

// vue2.x
export default (str) => {
  return xss(str, options)
}

// vue3.x
const xssFn=(str)=>{
    return xss(str,options)
}
export default {
    install(app){
        app.config.golbalProperties.$xss=xssFn
    }
}
```

3.挂载至vue原型上

- vue2：`main.js`

```js
import xssFn from 'xss.js'
...
new Vue({
    beforeCreate(){
        Vue.prototype.$xss=xssFn
    }
})
```

- vue3：`main.js`

```js
import xss from 'xss.js'
...
createApp(App).use(xss).mount('#app')
```

4.覆写html指令

`vue.config.js`[配置参考 | Vue CLI (vuejs.org)](https://cli.vuejs.org/zh/config/)

```js
module.exports = defineConfig({
	...
    chainWebpack:config=>{
        config.module
        	.rule('vue')
        	.use('vue-loader')
        	.loader('vue-loader')
        	.tap(options=>{
            	options.compilerOptions.directives={
                    html(node,directiveMeta){
                        (node.props||(node.props=[])).push({
                            name:'innerHTML',
                            value:`xss(_s(${directiveMeta.value}))`
                        })
                    }
                }
            	return options
        })
    }
})
```

5.此时使用v-html会默认过滤xss

---

##### vue项目部署服务器后刷新404

**原因(history模式)**

- vue是属于SPA，打包后只有一个`index.html`
- `nginx`配置：location只配置了首页`/`，当访问`www.xxx.com`时，打开`index.html`；若再跳转至其他页`www.xxx.com/login`，若如果此时刷新，就找不到`www.xxx.com/login`，因为没有配置，所以404

```
server {
  listen  80;
  server_name  www.xxx.com;

  location / {
    index  /data/dist/index.html;
}
```

- `hash`虽然出现在`URL`中，但并不会包含在`HTTP`请求中



**解决 [devserver配置historyapifallback](https://webpack.js.org/configuration/dev-server/#devserverhistoryapifallback)**

`vue.config.js`

```js
module.exports = defineConfig({
	...
    devServer:{
        // 404页面重跳至首页
        historyApiFallback:true		// 默认false
    }
})
```

配置后，`nginx.conf`文件发生变化

```
server {
  listen  80;
  server_name  www.xxx.com;

  location / {
    index  /data/dist/index.html;
    # 新增
    try_files $uri $uri/ /index.html;
}
```

---

Vue全家桶

vue-cli、vueRouter、vuex、Axios、UI框架(iview、vant、elementUI)

---

##### HTTP状态码

- 200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回
- 201（已创建）：请求成功并且服务器创建了新的资源
- 204（无内容）：服务器成功处理请求，但服务器不会发送响应体（Response Body）
- 206（部分内容）：服务器成功处理了部分请求
- 400（错误请求）：参数有误，请求无法被服务器识别
- 401（未授权）： 请求要求身份验证
- 403（禁止）： 服务器拒绝请求，禁止访问
- 404（未找到）： 服务器找不到请求的网页
- 408（请求超时）： 服务器等候请求时发生超时
- 500（服务器内部错误）：服务器遇到错误，无法完成请求
- 502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应
- 503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）
- 504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求

---

##### 算法(Algorithm)

1.定义：是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制

2.特性

- 有限性（Finiteness）：一个算法必须保证执行有限步之后结束
- 确切性（Definiteness）： 一个算法的每一步骤必须有确切的定义
- 输入（Input）：一个算法有零个或多个输入，以刻画运算对象的初始情况，所谓零个输入是指算法本身给定了初始条件
- 输出（Output）：一个算法有一个或多个输出。没有输出的算法毫无意义
- 可行性（Effectiveness）：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，即每个计算步骤都可以在有限时间内完成（也称之为有效性）

---

算法中的事件复杂度和空间复杂度

- 时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。
- 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述
- (排序算法)稳定性：排序前后两个相等的数相对位置不变，则算法稳定

---

常见的排序算法

- 冒泡排序
- 选择排序
- 插入排序
- 归并排序
- 快速排序

---

冒泡算法(Bubble Sort)

- 核心：两两对比，交换位置

```js
20  6  18  39  2(小=>大)

第一次(i=0)：两两比较4次=>6  18  20  2  39
第二次(i=1)：两两比较3次=>6  18  2  20  39
第三次(i=2)：两两比较2次=>6  2  18  20  39
第四次(i=3)：两两比较1次=>2  6  18  20  39

function bubbleSort(arr){
    // 5个数--遍历4次(外层)
	for(let i=0；i<arr.length-1；i++){
		// 两两比较(遍历)
		for(let j=0；j<arr.length-1-i；j++){
			if(arr[j]>arr[j+1]){
            	let temp=arr[j]
            	arr[j]=arr[j+1]
            	arr[j+1]=temp
        	}
		}
	}
    return arr
}
```

---

##### SPA首屏优化

- 减少入口文件体积：常用手段是路由懒加载
- 静态资源本地缓存：合理利用`localstorage`
- UI框架的按需加载：`element-UI` 或者`vant`都提供按需加载
- 图片资源的压缩：可以使用`icon`、雪碧图(将众多小图标合并到同一张图上)
- 开启GZip压缩：需要安装插件`compression-webpack-plugin`，在`vue.config.js`中进行配置
- 服务端渲染：组件或页面通过服务器生成html字符串，再发送到浏览器

---

##### NodeJS

fs(filesystem)：NodeJS中提供文件读写的模块

```js
const fs = require('fs')
```

- 文件读取

```js
// 同步读取
let data=fs.readFileSync('1.txt','utf8')

// 异步读取
fs.readFile('1.txt','utf8',(err,data)=>{
    if(!err){
        // data...
    }
})
```

- 文件写入(会覆盖原内容)

```js
// 同步写入
fs.writeFileSync('2.txt','Hello World')

let data = fs.readFileSync("2.txt", "utf8");
console.log(data); // Hello world

// 异步写入
fs.writeFile('2.txt','Hello World',err=>{
    if (!err) {
        fs.readFile("2.txt", "utf8", (err, data) => {
            console.log(data); // Hello world
        });
    }
})
```

- 文件追加写入(追加，不会覆盖原内容)

```js
// 同步追加
fs.appendFileSync('2.txx','!!!')
let data = fs.readFileSync("2.txt", "utf8");
console.log(data); // Hello world!!!

// 异步追加
fs.appendFile("2.txt", " @@@", err => {
    if (!err) {
        fs.readFile("2.txt", "utf8", (err, data) => {
            console.log(data); // Hello world!!!@@@
        });
    }
});
```

- 文件拷贝

```js
// 同步拷贝	 copyFileSync(源文件，目标文件)
fs.copyFileSync("2.txt", "3.txt");
let data = fs.readFileSync("3.txt", "utf8");
console.log(data); // Hello world!!!@@@

// 异步拷贝
fs.copyFile("3.txt", "4.txt", () => {
    fs.readFile("4.txt", "utf8", (err, data) => {
        console.log(data); // Hello world!!!@@@
    });
})
```

- 创建目录(必须保证传入的路径前面的文件目录已存在，否则会抛出异常)

```js
// 同步创建
// 假设已经有了 a 文件夹和 a 下的 b 文件夹
fs.mkdirSync("a/b/c")

// 异步创建
fs.mkdir("a/b/c/d", err => {
    if (!err) console.log("创建成功");
});
```

---

##### [JWT(JSON Web Token)](https://vue3js.cn/interview/NodeJS/jwt.html)

本质是一个字符串，由三部分组成：头部(Header)、载荷(Payload)、签名(Signature)，以`.`进行拼接

- Header：主要声明使用的算法
- Payload：服务器发给浏览器的信息，例如：用户`id`和`username`——身份信息(令牌)
- Signature：由设置的密钥`secretKey`对`Header`和`Payload`进行签名后生成

以上三者通过`.`连接(借助token生成的第三方库[jsonwebtoken](https://www.npmjs.com/package/jsonwebtoken))就生成了一个token

![img](https://raw.githubusercontent.com/ethanlamm/notes/image/img/052904c0-cd89-11eb-ab90-d9ae814b240d.png)

[jsonwebtoken](https://www.npmjs.com/package/jsonwebtoken)还有验证token、配置token等其他功能

借助第三方库[jsonwebtoken](https://www.npmjs.com/package/jsonwebtoken)可轻松实现生成token和验证token

---

##### 项目token问题

![image-20221102160353350](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221102152344039.png)



---

##### 真实DOM和虚拟DOM

真实DOM：文档对象模型，是在页面渲染出来的每一个真实DOM结构

虚拟DOM： 用 JavaScript 对象表示 DOM 信息和结构，是对真实DOM的一层抽象

为什么要用虚拟DOM：

- 创建虚拟DOM就是为了更好将虚拟的节点渲染到页面视图中

- 虚拟DOM的特点是不会进行回流和重绘，能够有效避免真实DOM树频繁更新，提高性能；操作虚拟DOM就是对 JavaScript 对象进行操作，比使用传统原生API或jQuery操作DOM方便、简单

---

##### vuex和pinia持久化

vuex的持久化：[vuex-persistedstate](https://www.npmjs.com/package/vuex-persistedstate)

`store/index.js`

```js
// 引入其他仓库
import cart from './modules/cart'
import category from './modules/category'
import user from './modules/user'

export default createStore({
  modules: {
    cart, category, user
  },
  plugins: [
    createPersistedstate({
      key: 'vuex',
      paths: ['user', 'cart']
    })
  ]
})
```



##### pinia的持久化：[pinia-plugin-persist](https://www.npmjs.com/package/pinia-plugin-persist)

```js
// 注意这种方法有bug，建议分开存储
export const useMainStore = defineStore('main', {
    state: () => {
        return {
            count: useCountStore(),
            user: useUserStore()
        }
    },

    persist: {
        enabled: true,
        strategies: [
            {
                key: 'count',
                storage: localStorage,
                paths:['count']
            }
        ]
    }
})
```



pinia对比vuex：

- 选项式 API 和组合式 API 都支持
- 没有了 Mutatios
- 没有了模块嵌套
- 支持 TS
- 没有命名空间模块

---

##### 小程序生命周期

- 应用生命周期

| 生命周期 | 说明                                    |
| -------- | --------------------------------------- |
| onLaunch | 小程序初始化完成时触发，全局只触发一次  |
| onShow   | 小程序启动，或从后台进入前台显示时触发  |
| onHide   | 小程序从前台进入后台时触发              |
| onError  | 小程序发生脚本错误或 API 调用报错时触发 |

- 页面生命周期

| 生命周期 | 说明                              | 作用                           |
| -------- | --------------------------------- | ------------------------------ |
| onLoad   | 生命周期回调—监听页面加载         | 发送请求获取数据               |
| onShow   | 生命周期回调—监听页面显示         | 请求数据                       |
| onReady  | 生命周期回调—监听页面初次渲染完成 | 获取页面元素（少用）           |
| onHide   | 生命周期回调—监听页面隐藏         | 终止任务，如定时器或者播放音乐 |
| onUnload | 生命周期回调—监听页面卸载         | 终止任务                       |

---

##### 小程序路由跳转的方式

| 原生微信        | uni-app          | 作用                                                         |
| --------------- | ---------------- | ------------------------------------------------------------ |
| wx.navigateTo   | uni.navigateTo   | 保留当前页面(onHide)，跳转到应用内的某个页面(非tabbar页面)   |
| wx.navigateBack | uni.navigateBack | 关闭当前页面(onUnload)，返回上一页面或多级页面               |
| wx.redirectTo   | uni.redirectTo   | 关闭当前页面(onUnload)，跳转到应用内的某个页面(非tabbar页面) |
| wx.switchTab    | uni.switchTab    | 跳转到tabBar页面，并关闭其他所有非tabBar页面                 |
| wx.reLaunch     | uni.reLaunch     | 关闭所有页面，打开到应用内的某个页面                         |

---

##### 提高小程序打开速度

**小程序启动加载性能**：

- 代码压缩：勾选开发者工具中 “上传代码时，压缩代码” 选项
- 分包加载
- 首屏优化（利用缓存)

**小程序渲染性能**：

- 避免不当的使用setData
- 使用自定义组件：自定义组件的更新并不会影响页面上其他元素的更新

---

小程序(uni-app)

下拉刷新：[onPullDownRefresh](https://uniapp.dcloud.net.cn/api/ui/pulldown.html#onpulldownrefresh)	[wx.stopPullDownRefresh](https://developers.weixin.qq.com/miniprogram/dev/api/ui/pull-down-refresh/wx.stopPullDownRefresh.html)	[uni.stoppulldownrefresh](https://uniapp.dcloud.net.cn/api/ui/pulldown.html#stoppulldownrefresh)

触底加载：[onReachBottom](https://uniapp.dcloud.net.cn/tutorial/page.html#lifecycle)

---

##### cookie、session和storage

**cookie**： `cookie`的出现是为了解决`HTTP`无状态导致的问题——服务器记不住每个客户端(浏览器)，需要给每个客户端(浏览器)打一个标签(`cookie`)。`cookie`存储于浏览器端。`cookie`由`name`、`value`和其他几个用于控制 `cookie`有效期、安全性、使用范围的可选属性组成

```sh
// Expires 用于设置 Cookie 的过期时间
Expires=Wed, 21 Oct 2015 07:28:00 GMT

//Max-Age 用于设置在 Cookie 失效之前需要经过的秒数（优先级比Expires高）
Max-Age=604800

// Domain指定了 Cookie 可以送达的主机名

// Path指定了一个 URL路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部
Path=/docs   # /docs/Web/ 下的资源会带 Cookie 首部

// 标记为 Secure的 Cookie只应通过被HTTPS协议加密过的请求发送给服务端
```

**cookie基本流程**

浏览器发起HTTP请求到服务器，服务器进行`cookie`设置，也就是在`Response Header`中的`Set-Cookie`字段中设置`cookie`，服务器可以设置多个`cookie`，每个`cookie`对应一个`Set-Cookie`字段；

`cookie`有`name`和`value`两个属性(实际上就是**一个键-值对**，也可以当作一个存储功能)，服务器**按实际需求**来把两个值填充完整后发给浏览器，浏览器会保存起来，这样浏览器以后的每个请求都会在`Request Header`的`Cookie`字段自动附上已存储的`cookie`(name=value)，服务器收到`cookie`用以区分不同的浏览器



**session**：`session`是一种数据结构(存储信息)，存储于服务器端。

**基于cookie的session**：利用`cookie`的结构(key-value)存储session ID——`cookie`(key-session ID)，而每个session ID与`session`成对应关系

**原理**：

1. 服务器在接受客户端⾸次访问时，在服务器端创建`session`(保存标识该浏览器的信息)，同时给这个`session`⽣成⼀个唯⼀的标识字符串session ID(签名)
2. 服务器在`Response Header`的`Set-Cookie`字段中设置`cookie`(key-session ID)
3. 浏览器中收到响应时，解析`Response Header`，然后将session ID保存在本地`cookie`中，浏览器在下次http请求时，会在`Request Header`带上该域名下的`cookie`(key-session ID)
4. 服务器在接受客户端请求时，会去解析`Request Header`中的`cookie`中的session ID，然后根据这个session ID去找服务器端保存的该客户端的`session`，判断session ID是否合法，或返回`session`存储的信息

![image.png](https://raw.githubusercontent.com/ethanlamm/notes/image/img/a8b27ee891b9407391b567742f295d0e%7Etplv-k3u1fbpfcp-zoom-in-crop-mark%3A4536%3A0%3A0%3A0.awebp)

配置稍微不同：

- [koa-session](https://www.npmjs.com/package/koa-session)
- [express-session](https://www.npmjs.com/package/express-session)



小例子：基于cookie的session(NodeJS-Express) ，需要设置session，用到第三方库 [express-session](https://www.npmjs.com/package/express-session)

![image-20220902210928235](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20220905094202889.png)







`cookie`和`session`的区别

Cookie和Session都用于存储信息。它们最主要的区别在于Cookie存储在客户端上,而Session则存储在服务器上



**cookie**

- 类比：会员卡机制
- 优点：自动发送、域名独立、过期时限、4KB限制
- 缺点：不具有安全性(可伪造)、不支持跨域访问(前端请求后端)

**基于cookie的session**

- 类比：会员卡 + 刷卡认证
- 优点：cookie的优点
- 缺点：不支持跨域访问（服务器之间的session数据不共享）



关于`cookie`、`sessionStorage`、`localStorage`三者的区别主要如下：

- 存储大小：`cookie`数据<`4k`，`sessionStorage`和`localStorage`可以达到5M或更大
- 有效时间：`localStorage`存储持久数据； `sessionStorage`数据在当前浏览器窗口关闭后自动删除；`cookie`有自身设置的有效期
- 数据与服务器之间的交互方式：`cookie`的数据会自动的传递到服务器，服务器端也可以写`cookie`到客户端； `sessionStorage`和`localStorage`不会自动把数据发给服务器，仅在本地保存



应用场景

- 标记用户与跟踪用户行为的情况，推荐使用 `cookie`
- 适合长期保存在本地的数据（令牌），推荐使用 `localStorage`
- 敏感账号一次性登录，推荐使用 `sessionStorage`

---

##### Vue-Cli与Vite的主要区别

Vite在开发环境下基于浏览器原生ES6 Modules提供功能支持，在生产环境下基于RollUp打包，Vue Cli不区分环境，都是基于Webpack。可以说在生产环境下，两者都是基于源码文件，RollUp和Webpack都是将代码进行处理，并提供出浏览器页面所需要的HTML，JavaScript，CSS，图片等静态文件。但是对于开发环境的处理，两者却有不同：

- Vue Cli在开发环境下也是基于对源码文件的转换，即利用Webpack对代码打包，结合webpack-dev-server提供静态资源服务。
- Vite在开发环境下基于浏览器原生ES6 Modules，无需对代码进行打包直接让浏览器使用。

Vite正是因为利用浏览器原生功能，而省略掉耗时的打包流程，才使得开发环境下体验非常快。

---

vue 指令

```js
v-text 只能用在双标签中，其实就是给元素的innerText赋值
v-html 其实就是给元素的innerHTML赋值
v-if  v-else  v-else-if
v-show
v-bind
v-model
v-on
```

---

##### vue组件通信(7种)

1. 通过 props 传递
2. 使用 ref
3. Provide 与 Inject
4. 通过 $emit 触发自定义事件
5. EventBus
6. $parent 或$root
7. Vuex

---

##### Vue3特点

- **更小**：移除一些不常用的 `API(EventBus filter)`；引入`tree-shaking`，可以将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了
- **更快**：diff算法优化；静态提升；事件监听缓存；SSR优化
- **更友好**：TypeScript支持；组合式API，逻辑清晰，复用性大；提高自身可维护性

Vue3做了哪些优化

- 源码：`vue3`整个源码是通过 `monorepo`的方式维护，使得模块拆分更细化，更容易阅读、理解和更改所有模块源码，提高代码的可维护性；
- 性能：数据劫持优化

```js
在vue2中，数据劫持是通过Object.defineProperty，这个 API 有一些缺陷，并不能检测对象属性的添加和删除，但vue2提供了set和delete方法（Vue 不能检测数组和对象的变化）

vue3是通过proxy监听整个对象，对于深层次的变化，Vue3的处理方式是在 getter 中去递归响应式
```

- 语法API：组合式API，优化逻辑组织、优化逻辑复用

---

this指向

1. 普通函数中this指向window
2. 构造函数中，this指向构造函数new出来的实例对象
3. 箭头函数没有this，指向取决外部环境
4. 定时器中的this指向window

---

递归

定义：在一个函数内部可以自身调用

优点：结构清晰，可读性强

缺点：可能会栈溢出

---

##### apply、call、bind的区别

- 相同点 : 作用一致，修改函数this指向

- 不同点 :

1）传参方式不同 : call和bind是传入参数列表(call一次性传入，bind可分次传入)， apply传入数组

2）执行机制不同 : apply和call会立即执行函数，而bind不会立即执行而是得到修改this的新函数

---

##### 数组去重的方法

```js
1.[...new Set(arr)]

2.function unique (arr) {
  return Array.from(new Set(arr))
}

3.forEach + indexOf/includes
function removeDuplicate(arr) {
  const newArr = []
  arr.forEach(item => {
  	// 新数组不存在该item时，push数据
    if (!newArr.includes(item)) {  // newArr.indexOf(item)==-1
      newArr.push(item)
    }
  })
  return newArr
}

4.filter + indexOf
function removeDuplicate(arr) {
  return arr.filter((item, index) => {
    return arr.indexOf(item) === index
  })
}

5.双重for循环 + splice
function removeDuplicate(arr){
    let len=arr.length
	for(var i=0; i<len; i++){
        for(var j=i+1; j<len; j++){
            if(arr[i]==arr[j]){
                arr.splice(j,1);
                len--;
                j--;
            }
        }
    }
	return arr;
}
```

---

##### 清除浮动

- 父元素设置高度`hight`
- 父元素使用`overflow:hidden`
- 父元素设置伪类

```css
// 单伪元素
.clearfix::after{
    content:'';
    display:block;
    hight:0;
    visibility:hidden;
    clear:both;
}

// 双伪元素
.clearfix::before, .clearfix::after{
    content:'';
    display:table;
}
.clearfix::after{
    clear:both;
}
```

- 最后一个浮动元素后加空div标签并添加样式 `clear:both`

```html
<div class="container">
    <p>1</p>
    <p>2</p>
    <p>3</p>
    <div style="clear: both;"></div>
</div>
```

---

##### vue中computed 和watch 的区别是什么？

computed

- 数据源：基于data中的数据或父组件传递的props数据
- 支持缓存：只有数据源发生变化时才会调用；否则，直接取缓存中的计算结果
- 不支持异步

watch

- 数据源：data、props、computed
- 不支持缓存：只要数据源发生变化，直接触发相应操作
- 支持异步

---

##### 盒子模型

- 标准盒子模型：`width`和`height`指的是内容区域的宽度和高度，不包含`padding`和`border`，即 `box-sizing:content-box(默认)`
- IE模型：`width`和`height`指的是内容区域的宽度或高度，加上`padding`和`border`，即 `box-sizing:border-box`

textarea禁止拉伸

```css
textarea {
  resize: none;
}
```

---

##### Get和Post的区别

- 传参不同：`Get`参数拼接到url后；`Post`参数在请求体中
- 数据大小不同：`Get`限制大小 2-5mb；`Post`没有限制大小
- 传输速度不同：`Get`传输快；`Post`传输慢
- 安全性不同：具体情况
- 幂等不同：所谓的幂等，意思是多次执行相同的操作，结果都是相同的。`Get`是幂等的，`Post`不是幂等的

---

##### BFC（Block Formatting Context）

即**块级格式化上下文**，它是页面中的一块渲染区域；

`BFC`目的是形成一个相对于外界完全独立的空间，让内部的子元素不会影响到外部的元素，反之亦然

触发条件：

- 根元素，即HTML元素
- 浮动元素：float值为left、right
- overflow值不为 visible，为 auto、scroll、hidden
- display的值为inline-block、inltable-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid
- position的值为absolute或fixed

---

一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？
1.浏览器查找域名对应的ip地址，DNS查询

2.浏览器向服务器发送http请求（TCP三次握手)

3.TCP/IP连接建立，浏览器发送http的get请求，服务器返回一个http响应

4.浏览器进行dom树构建，获取html资源，显示完成页面

`输入URL`=>`URL解析`=>`DNS查询`=>`TCP连接(三次握手)`=> `浏览器发出HTTP请求` => `服务器接收请求并发回响应`=>`浏览器接收响应`=>`渲染页面`

---

浏览器关键渲染路径：

**DOM** => **CSSDOM** => DOM+CSSDOM => **Renfer Tree**(渲染树) => **Layout**(计算每一个元素在设备视口内的确切位置和大小) => **Paint**(将渲染树中的每个节点转换成屏幕上的实际像素,这一步通常称为绘制或栅格化)



回流(重排`Reflow`)和重绘`Repaint`

- 回流(重排`Reflow`)：此时在关键渲染路径中的 Layout 阶段，计算每一个元素在设备视口内的确切位置和大小。当一个元素位置发生变化时，其父元素及其后边的元素位置都可能发生变化，代价极高
- 重绘(Repaint)：元素的样式发生变动，但是位置没有改变。此时在关键渲染路径中的 Paint 阶段，将渲染树中的每个节点转换成屏幕上的实际像素，这一步通常称为绘制或栅格化

---

inline元素：`margin`左右生效，上下不生效；`padding`左右生效，上下不生效(在上下方向不会挤压其他元素)，但在DevTools中可以看到上下方向的`padding`存在

---

##### csss specificity(选择器权重)

<img src="https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20220905095305598.png" alt="image-20220905094202889" style="zoom: 50%;" />



- 如何匹配最前三个子元素: `:nth-child(-n+3)`
- 如何匹配最后三个子元素: `:nth-last-child(-n+3)`

---

`+`选择器和`~`选择器

- `+` 选择器匹配紧邻的兄弟元素
- `~` 选择器匹配随后的所有兄弟元素

![image-20220905095305598](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20220905122331524.png)

---

有哪些 css 属性不能展示动画效果

- display：不能在 display:none 和 display:block 之间进行动画，用opacity
- height：不能在 height:0 和 height:auto 之间进行动画

---

##### 暗黑模式

```css
// html
html{
    filter: invert(1) hue-rotate(180deg);
    transition：all 300ms;
}

// 处理图片、背景background、video等应该保持原样的元素，可以给这些元素添加相同的类名 exclude
.exclude {
	filter: invert(1) hue-rotate(180deg);
}
```

- **invert**滤镜：可以帮助反转应用程序的颜色方案，因此，黑色变成了白色，白色变成了黑色，所有颜色也是如此。
- **hue-rotate**滤镜：可以帮助我们处理所有其他非黑白的颜色。将色调旋转180度，我们确保应用程序的颜色主题不会改变，而只是减弱它的颜色。

---

grid布局：大屏三等分、中屏二等分、小屏一等分

![image-20220905122331524](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20220906145224052.png)

![image-20220905122331524](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20220906152415939.png)

---

##### 文本省略号

单行文本省略号

```css
.ellipsis{
    overflow:hidden;
    white-space:nowrap;
    text-overflow:ellipsis;
}
```

多行文本省略号

```css
.ellipsis{
    overflow:hidden;
    display:-webkit-box;
    -webkit-box-orient:vertical;
    -webkit-line-clamp:2;
}
```

---

##### rem、em、vw、vh 的值各是什么意思

- `rem`: 根据根元素(即 `html`)的 `font-size`
- `em`: 根据**自身元素**的 `font-size`
- `vw`: viewport width
- `vh`: viewport height

---

判断移动端还是PC端

方法一：navigator.userAgent

```js
//定义一个函数判断是手机端还是pc端
function isMobile() {
    let reg=/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i
	if (window.navigator.userAgent.match(reg)) {
    	return true; // 移动端
    } else {
        return false; // PC端
    }
}
//  判断后的操作
if (isMobile()) {
	console.log('移动端');
    // 判断true跳转到这个主页
    // location.href = "./mobile/index.html"
} else {
    console.log('PC端');
    // 判断false跳转到这个主页
    // location.href = "./pc/index.html"
}
```

方法二：

第三方库 [ismobilejs](https://www.npmjs.com/package/ismobilejs) -----对方法一的封装

---

##### 网址的组成

```
https://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#anchor
```

- **协议**：`https://` 表示HTTPS协议；默认HTTP协议，如果省略协议，直接在浏览器地址栏输入`www.example.com`，那么浏览器默认会访问`http://www.example.com`。

- 信息资源地址：

​			1）**主机名(域名)**：`www.example.com`

​			2）**端口号**：`80`

- **路径名**：`/path/to/myfile.html`

- **查询参数**：`?key1=value1&key2=value2`
- **锚点**：`#anchor`，浏览器加载页面以后，会自动滚动到锚点所在的位置。



域名的分类

<img src="https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20220906152622247.png" alt="image-20220906145224052" style="zoom: 50%;" />



域名和ip对应关系 

<img src="https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20220906173154777.png" alt="image-20220906152415939" style="zoom: 67%;" />

<img src="https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221008140722857.png" alt="image-20220906152622247" style="zoom: 50%;" />



*有些主机没有域名，只有 IP 地址，比如`192.168.2.15`。这种情况常常出现在局域网。*

---

如何找到当前页面出现次数最多的 HTML 标签

（同问题：找出一组数中出现次数最多的数，以及其出现的次数）

```js
// 获取当前页面所有HTML标签
const allelements = document.querySelectorAll('*')
// 其他方法
// document.getElementsByTagName('*')
// $$('*')，可在浏览器控制台使用
// document.all，已废弃，不建议使用

function findMost(arr) {
  let temp = {}
  let maxNum = 0
  let maxEle = null
  for (let i = 0; i < arr.length; i++) {
    let ele = arr[i].tagName  // 标签名
    temp[ele] === undefined ? temp[ele] = 1 : temp[ele]++
    if (temp[ele] > maxNum) {
      maxNum = temp[ele]
      maxEle = ele
    }
  }
  // 应考虑次数相同的情况
  let eleArry=[]
  for (let key in temp) {
    if(temp[key]===maxNum){
      eleArry.push(key)
    }
  }
  return { eleArry ,maxNum}
}
let result = findMost(allelements)
console.log(result);
```

---

- `e.target` 指向触发事件的对象。
- `e.currentTarget` 指向添加监听事件的对象(事件绑定的对象)。

<img src="https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221102160229935.png" alt="image-20220906173154777" style="zoom: 50%;" />

---

事件捕获、事件冒泡、on事件
总顺序：捕获事件 ==> 冒泡事件(addEventListener) 或 on事件
冒泡事件addEventListener 和 on事件的执行顺序：按照定义时的顺序执行(书写代码的先后)
并且，冒泡事件addEventListener不会覆盖，有多少个事件就执行多少个，按顺序执行
而，相同的on事件会覆盖，后面的覆盖前面的

---

##### 文件上传

```html
<form action="http://localhost:8080/api/upload" method="post" enctype="multipart/form-data">
    <input type="file" name="file" id="file" value="" multiple="multiple" />
    <input type="submit" value="提交"/>
</form>
```

- `action` 就是我们的提交到的接口
- `enctype="multipart/form-data"` 就是指定上传文件格式
- `input` 的 `name` 属性一定要等于`file`

---

可选链操作符`?.`

```js
const o = {};

// 添加可选链之前
o && o.a && o.a.b && o.a.b.c && o.a.b.c.d;

// 添加可选链之后
o?.a?.b?.c?.d;
```

---

##### 零碎知识点

- 查看项目使用的node版本：`package.json`中的`engines`
- 图片裁剪：CSS属性——`clip=path:circle(40%)`

```css
img{
    clip=path:circle(40%)
}
```

- 删除项目中没有使用的package：[第三方库 depcheck](https://juejin.cn/post/7041004672626196510)
- [禁止普通页面文本复制](https://zhuanlan.zhihu.com/p/348299601)、[HTML 禁止复制文字](https://blog.csdn.net/baidu_23275675/article/details/83302425)：注意由`Vue`制作的页面**默认**是不能进行文本复制的，若需要，使用第三方库[clipboard](https://www.npmjs.com/package/clipboard)
- [vue项目、env 文件与环境变量和模式](https://www.jianshu.com/p/33428dd6cb8a)
- 权限设计中的RBAC：Role-Based Access Control(基于角色访问权限管理模型)，有3个基础组成部分，分别是：用户、角色和权限。RBAC通过定义角色的权限，并对用户授予某个角色从而来控制用户的权限，实现了用户和权限的逻辑分离（区别于ACL模型）。不同角色对应不同权限，用户可充当多个角色
- 使用node.js搭建HTTPS服务器：需要安装[OpenSSL](https://zhuanlan.zhihu.com/p/42594396)。相关文章——[怎么用Node.js创建HTTPS服务器](https://developer.aliyun.com/article/762524#:~:text=要启动https服务器，请在终端上运行 node app.js,(这里，app.js是文件的名称)。 现在你的服务器已经设置并启动，在浏览器中可以访问 https%3A%2F%2Flocalhost%3A8000%2F)、[Node.js 搭建 HTTPS 服务器 - 腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1730194)
- [Javascript 常用的六种设计模式介绍](https://juejin.cn/post/7061987842473345061)

---

##### SEO优化

原理：当搜索进行时，它会从“蜘蛛”事先抓取到的大量有关联性的索引中，搜索所有包含用户输入的关键字的网页，然后根据算法给出每个网页一个总评分，再根据评分的高低给用户返回搜索结果。而这些包含关键字的内容，可以是**文章标题**、**描述**、**关键字**、**内容**、甚至是**链接**等。

我们可以从以上方面入手：

- 创建唯一且准确的网页标题`<title>`
- 使用`<meta>`元标签：使用 `<meta>` 的 `keywords` 元数据来提炼网页重要关键字，使用 `<meta>` 的 `description` 元数据来准确总结网页内容
- 使用语义化标签：header、nav、section等
- 利用`<img>`标签的`alt`属性：`alt`属性可以在图片未成功显示时候，使用文本来代替图片的呈现，可以增强内容的相关性，提高关键词密度
- 友情链接：相互推广
- 合理安排重要内容的位置：将重要内容的 HTML 代码放在最前面，搜索引擎抓取HTML顺序是从上到下的，保证重要内容比=被首先抓取



---

##### for...in

1.`for...in`遍历对象时：`for(let key in obj){}`，遍历的是`key`

2..`for...in`遍历数组时：`for(let index in arr){}`

​	1）遍历的是`index`，并且是字符串型数字，不能直接进行几何运算

​	2）遍历的顺序可能不是按照实际数组的内部顺序

3.使用`for...in`遍历对象或数组时，会遍历所有的可枚举属性，包括**原型**上的方法和属性

因此，`for...in`适合遍历对象，并且使用[hasOwnProperty( )](https://blog.csdn.net/a791226606/article/details/110679991)方法可以判断某属性是不是该对象的**实例**属性

```js
Object.prototype.method = function () {
    console.log(this);
}
var myObject = {a: 1,b: 2,c: 3}
for (var key in myObject) {
    if(myObject.hasOwnProperty(key)) {
        console.log(key);
    }
}
```



##### for...of

`fo...of`适用于遍历数组，`for(let value of arr){}`，遍历的是数组的元素，并且不包含原型的方法和属性、以及不会遍历非数字键名的属性

```js
var myArray = [1, 2, 3, 4, 5, 6, 7]
myArray.name = "数组"
for (var value of myArray) {
    console.log(value);
}
```

`for...of`遍历对象时，遍历的是`value`值



---

字符串替换

- `str.split('foo').join('bar')`
- `str.replace(/foo/g,'bar')`
- `str.replaceAll('foo', 'bar')`

---

##### [script 标签脚本的加载和执行顺序](https://zhuanlan.zhihu.com/p/464633848)

![img](https://raw.githubusercontent.com/ethanlamm/notes/image/img/v2-8df9d864a263990fee83b48b29c987ad_1440w.jpg)

- 内联脚本
- 外部脚本
  1. 普通外部脚本
  2. defer 外部脚本
  3. async 外部脚本
  4. async 外部脚本

- 对于同步阻塞的脚本，显然只有当这些脚本都执行完成之后，才会触发 `DOMContentLoaded` 事件，最后再触发 `load` 事件

```
DOMContentLoaded事件：仅DOM加载完毕
load事件：文档内容全部加载完成，包括图片、样式等
```

- 无论在什么情况下， `load` 事件将作为兜底事件在最后被触发
- 非 async 脚本尽力顺序执行，async 脚本乱序执行

---

##### Vue2.0和Vue3.0响应式的区别

- Vue2.0

1. 基于Object.defineProperty，不具备监听数组的能力，无法检测到对象属性的添加和删除 。
2. 由于Vue会在初始化实例时对属性执行getter/setter转化，所有属性必须在data对象上存在才能让Vue将它转换为响应式。
3. 深度监听需要一次性递归，对性能影响比较大。

- Vue3.0

1. 基于Proxy和Reflect，可以原生监听数组，可以监听对象属性的添加和删除。
2. 不需要一次性遍历data的属性，可以显著提高性能。
3. 因为Proxy是ES6新增的属性，有些浏览器还不支持,只能兼容到IE11 。

---

##### Vue2中data为什么必须式一个函数

组件就是一个可复用的vue的实例

这也就意味着如果你的data是一个普通的对象，那么所有复用这个实例的组件都将引用同一份数据，这就造成了数据污染！

这个时候如果我们将data封装成一个函数，我们在实例化组件的时候只是调用了这个函数生成的数据副本，这就避免了数据污染。

综上可知，如果data是一个函数的话，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。

所以说vue组件的data必须是函数。

---

##### [Vue-router核心原理](https://cloud.tencent.com/developer/article/1880448#/dwa)

实现的原理：监听`url`的变化，更新视图但不重新请求页面

两个重点：

1.如何检测 URL 变化了？

2.如何改变 URL 却不引起页面刷新？



使用到的API：`BOM(Browser Object Model)`浏览器对象模型，提供一个顶级像`winndow`，其中使用到`window`的[location](https://developer.mozilla.org/zh-CN/docs/Web/API/Location)属性、[history](https://developer.mozilla.org/zh-CN/docs/Web/API/History)属性



- Hash 模式

```
例如：https://www.example.com/#/hash_abc

location.hash	// #/hash_abc
```
hash 虽然出现在URL上，但不会被包括在HTTP请求中，因此，改变hash不会重新加载页面

| 改变URL                               | 监听URL(事件) | router-view组件 |
| ------------------------------------- | ------------- | --------------- |
| `<a></a>`标签`href`属性<br />浏览器前进后退<br />`window.location.hash` | `hashchange` | 依据`location.hash`匹配路由表`routes`来渲染(`render`函数)对应的组件 |



- History 模式

```
例如：https://www.example.com/history_abc

location.pathname	// /history_abc
```
HTML5给`window.history`提供了两个方法——[History.pushState()](https://developer.mozilla.org/zh-CN/docs/Web/API/History/pushState)、[History.replaceState()](https://developer.mozilla.org/zh-CN/docs/Web/API/History/replaceState)，这两个方法改变URL的Path部分不会引起页面刷新

`popstate`事件不会监听到通过`pushstate`、`replacestate`、`a`标签改变URL？

| 改变URL                                                      | 监听URL(事件) | router-view组件                                              |
| ------------------------------------------------------------ | ------------- | ------------------------------------------------------------ |
| `<a></a>`标签`href`属性<br />`pushState()`、`replaceState()`<br />浏览器前进后退 | `popstate`    | 依据`location.pathname`匹配路由表`routes`来渲染(`render`函数)对应的组件 |

---

##### CSS 隐藏样式

01 display: none

通过 CSS 操控 display，移出文档流

```css
display: none;
```

02 opacity: 0

透明度为 0，仍在文档流中，当**作用于其上的事件(如点击)仍有效**

```css
opacity: 0;
```

03 visibility: hidden

透明度为 0，仍在文档流中，**但作用于其上的事件(如点击)无效**，这也是 `visibility:hidden` 与 `opacity: 0` 的区别

```css
visibility: hidden;
```

04 content-visibility

移出文档流，但是再次显示时消耗性能低

```css
content-visibility: hidden;
```

05 绝对定位于当前页面的不可见位置

```css
position: absolute;
top: -9000px;
left: -9000px;
```

06 字体大小设置为 0

```css
font-size: 0;
```

---

##### 深度选择器

1.原生样式	**>>>**

```css
.a >>> .b{}
```

2.使用了预处理器 scss、sass、less	**/deep/**（很少用）

```css
.a /deep/ .b{}
// 注意：vue-cli3以上版本不可以
```

3.vue2.0	**::v-deep**（双冒号）

```css
.a ::v-deep .b{}
```

4.vue3.0	**:deep()**（单冒号）

```css
.a :deep(.b){}
```



---

##### 样式兼容问题

![image-20221102160229935](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20220925093640579.png)



---

##### axios封装

1.设置请求前缀：根据开发、测试、生产环境(`process.env.NODE_ENV`)的不同，前缀(`axios.defaults.baseURL`)需要加以区分

2.设置超时事件：`timeout`

3.设置请求拦截和响应拦截

4.封装请求方法(默认暴露)

---

##### React

一、定义：用于构建用户界面的 JavaScript 库

二、特点

- JSX语法（JavaScript + XML）：在js中通过XML的方式直接声明DOM结构
- 单向数据绑定：修改数据需要通过 setState 修改

```js
vue和react都是单向数据流，vue和react父组件可以向子组件传递props，但子组件不能修改父组件传递过来的props，子组件只能通过事件通知父组件修改数据

vue支持双向绑定：v-model
react为单向数据绑定：修改数据需要通过 setState 修改
```

- 虚拟DOM
- 声明式编程
- Component：类组件（render函数返回要渲染的HTML）、函数式组件（直接返回）

三、生命周期

只有类组件才有生命周期（类组件需要实例化，函数组件不需要实例化）

![image-20220925093640579](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221006215640742.png)

四、props和state的区别

- props：外部传入，可读性，不可修改
- state：自身组件所拥有私有属性，通过 setState 修改

五、setState是同步还是异步

- 默认是异步的（性能优化、减少渲染次数）：组件的生命周期、合成事件中
- 同步情况：原生事件中（addEventListener 、setTimeout、setInterval）

六、构建组件的方式

- 函数式构建：在`React Hooks`之前是无状态组件
- 继承`React.Component`构建：类组件
- `React.createClass`方法构建(不常用)

七、组件通信

- 父子：`props`属性
- 子父：父组件通过`props`属性传递一个函数给子组件，子组件执行该函数时，父组件就得到子组件传递的值
- 兄弟：共同的父组件
- 父组件向后代组件：`context`提供一种组件通信方法
- 非关系组件：`Mbox`、`Redux`

八、受控组件和非受控组件

受控组件：一般是用来对表单进行处理的，使用`useState`和`onChange`事件，实现数据双向

非受控组件：使用`useRef`手动操作获取DOM的方式来获取组件的值

九、React Hooks

React Hooks是在React16.8以后提出的，可以使得函数式组件变成有状态组件。

常见

- useState：实现函数式组件状态的管理，返回一个数组，第一个元素是`state`初始值，第二个是更新`state`的函数
- useEffect：在函数式组件中实现一些带有副作用的操作，依据不同的**依赖项**执行的时机不同。如果没有依赖项，则初次渲染和每次更新都会执行；如果依赖项是空数组，则只有首次渲染会执行；如果是特定的依赖项，是首次渲染和依赖项发生改变时会执行
- useRef：在函数式组件中获取DOM元素、或者是获取类组件实例对象

十、引入CSS样式的方式

- 在`js`中写，将样式当做是一个变量，然后在模板中引入，代码冗杂
- 引入CSS样式文件，将样式抽离成一个独立文件，然后引入，是全局生效的
- 引入`.module.cs`文件，将CSS文件作为一个模块引入，只作用于当前组件，在`webpackage`配置`modules:true`即可

十一、路由

原理：不刷新页面的条件下，切换显示不同的页面

本质：检测`URL`的变化，根据`URL`显示不同的页面

`react-router-dom`是配置浏览器环境路由的，它提供一些**常用的API**：

- `BroswerRouter`、`HashRouter`：用来检测`URL`的改变的，作为顶层组件包裹其他组件。`BrowserRouter`是`history`模式，`HashRouter`是`hash`模式
- `Route`：用来路由匹配和组件渲染的。

```
path属性：设置匹配的路径
element属性：设置要渲染的组件
exact属性：开启精准匹配
```

- `Link`、`NavLink`（声明式导航）：用来路径跳转的。`to`属性设置要跳转的路径。`NavLink`是在`Link`基础之上增加了一些样式属性

```
activeStyle：活跃时（匹配时）的样式
activeClassName：活跃时添加的class
```

- `useNavigate`（编程式导航）：用来路径跳转的，`useNavigate`得到一个跳转的函数，在函数参数中填入要跳转的路径。

```js
const navigate=useNavigate()
navigate('/')
```

十二、路由传参：

1）searchParams传参：类似vue中的query传参，使用`useSearchParams`函数获取参数

2）params传参：类似vue中的params传参，使用`useParams`函数获取参数

十三、Mobx 状态管理

Mobx是一个独立的响应式的库，通常习惯把它和React进行绑定使用，用Mobx来做响应式数据建模，React作为UI视图框架渲染内容，需要下载**mobx框架**和**链接mobx和react的中间件**

```sh
npm i mobx mobx-react-lite
mobx-react-lite：只能用于函数式组件
mobx-react：类组件、函数式组件均能使用
```

步骤：

1. 在类中定义数据状态 **state**
2. 在构造器中使用 **makeAutoObservable** 实现数据响应式处理
3. 定义修改数据的函数 **action**(支持异步，修改state需要在runInAction中)、通过**get**关键词定义计算属性（函数形式，需要return）
4. 实例化**store**并导出
5. 使用：在组件中导**store**实例对象，那么就有了**store**定义的数据和修改数据的方法

```js
import { makeAutoObservable,runInAction } from "mobx"
import axios from "axios"

class ListStore{
    // state
    list = []
    count=1
    
    constructor() {
       makeAutoObservable(this)
    }
    
    // derivations(派生)、computed
    get double() {
        return this.count * 2
    }
    
    // actions
    async getList() {
        const res = await axios.get('http://geek.itheima.net/v1_0/channels')
        runInAction(() => {
            this.list = res.data.data.channels
        })
    }
}
export default new ListStore()
```

十四、React render函数

首先，`render`函数在React中有两种形式，在类组件中指的是`render`方法，在函数组件中指的是函数组件本身。在`renser`函数中编写`JSX`，转化成`js`，利用`createElement`来生产虚拟`DOM`，最终转化成真实`DOM`。

执行时机：

- 类组件中使用了 `setState` 方法，就一定会触发 `render` 函数执行
- 函数组件使用`useState`更改状态不一定导致重新`render`
- 组件的`props` 改变了，不一定触发 `render` 函数的执行；但是如果 `props` 的值来自于父组件或者祖先组件的 `state`，就会导致子组件的重新渲染

十五、React事件机制

`React`基于浏览器的事件机制自身实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等

在`React`中这套事件机制被称之为合成事件（SyntheticEvent），合成事件是 `React`模拟原生 `DOM`事件所有能力的一个事件对象，拥有与浏览器原生事件相同的接口

组件注册的事件最终会绑定在`document`这个 `DOM`上，使用一个统一的事件监听器去监听，当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率也有很大提升

自身实现了一套事件冒泡机制，阻止不同时间段的冒泡行为，需要对应使用不同的方法，对应如下：

- 阻止合成事件间的冒泡，用e.stopPropagation()
- 阻止合成事件与最外层 document 上的事件间的冒泡，用e.nativeEvent.stopImmediatePropagation()

![preview](https://raw.githubusercontent.com/ethanlamm/notes/image/img/view)

十六、Key的作用

在React diff算法中，React借助元素的`key`属性来判断元素是新创建的，还是被移动的元素，从而减少不必要的元素渲染。

注意事项：

- key值与具体的元素一一对应，是唯一的
- 尽量不要用数组的index作为key
- key也不要用随机数，随机数在下一次渲染时会重新生成

十七、React性能优化

- 避免使用内联函数：使用内联函数，则每次调用`render`函数时都会创建一个新的函数实例

```xml
 <input type="button" onClick={(e) => { this.setState({inputValue: e.target.value}) }} value="Click For Inline Function" />
```

- 懒加载组件：`Suspense`组件和 `lazy`

```js
import { lazy, Suspense } from 'react'

export const johanAsyncComponent = props => (
  <Suspense fallback={<Spinner />}>
    <johanComponent {...props} />
  <Suspense>
);
```

- 服务端渲染：[Next.js - React 应用开发框架](https://www.nextjs.cn/)



---

##### 原型、原型链

![image-20221008140722857](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221006215808860.png)

#

<img src="https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221007093929086.png" alt="image-20221006215640742" style="zoom: 33%;" />

#

![image-20221006215707669](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221006215707669.png)

#

![image-20221007093929086](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221006225741737.png)

#

![image-20221006215808860](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221007093639226.png)

#

<img src="https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221007220758124.png" alt="image-20221006225741737" style="zoom:67%;" />

#

![image-20221007093639226](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221007221054844.png)

---

##### new 关键字的具体过程

- 构造函数式

![image-20221007220758124](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221007220914809.png)

#

![image-20221007220914809](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221007220344912.png)



- 类


<img src="https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221008163442023.png" alt="image-20221007221054844" style="zoom: 67%;" />

#

![image-20221007220344912](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221021083844598.png)

---

##### 类的继承（**extends**关键字）

![image-20221008163442023](https://raw.githubusercontent.com/ethanlamm/notes/image/img/1782626178-bfa9c9ce6a459b9e_fix732.png)



---

##### [HTTP缓存策略](http://www.dennisgo.cn/Articles/Network/HttpCache.html)

一、协商缓存

1.**ETag(Entity Tag)** 和 **If-None-Match**

ETag：返回内容的一个`hash`值或者是一个数字版本号

- 服务器返回`ETag`，加到`response`的`header`中

```
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
```

- 客户端拿到`ETag`和返回值一起保存下来，下次请求，使用`If-None-Match`，加到`request`的`header`里面

```
If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d
```

- 然后服务端拿到请求里面的`If-None-Match`跟当前版本的`ETag`比较：

​	1）如果一样的，返回`304`，不返回内容(`body`)，只返回`header`，告诉浏览器直接用缓存

​	2）如果不一样，返回`200`和最新的内容



2.**Last-Modified** 和 **If-Modified-Since**

Last-Modified：最新修改时间

- 服务器返回`Last-Modified`，加到`response`的`header`中

```
Last-Modified: Wed, 21 Oct 2000 07:28:00 GMT
```

- 客户端拿到`Last-Modified`和返回值一起保存下来，下次请求，使用`If-Modified-Since`，加到`request`的`header`里面

```
If-Modified-Since: Wed, 21 Oct 2000 07:28:00 GMT
```

- 然后服务端拿到请求里面的`If-Modified-Since`跟当前版本的修改时间比较：

​	1）如果时间一样，返回`304`，不返回内容(`body`)，只返回`header`，告诉浏览器直接用缓存

​	2）如果修改时间比`If-Modified-Since`的时间晚，说明文件有更新，则返回`200`和最新的内容



**ETag和Last-Modified优先级**

`ETag`的优先级比`Last-Modified`高，`Last-Modified`只能精确到秒



二、强制缓存

1.**Expires**

Expires：过期时间

服务器返回`response`的`header`中

```
Expires: Wed, 21 Oct 2000 07:28:00 GMT
```

在这个时间前，客户端浏览器都不会再发起请求，而是直接用缓存资源



2.[Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)

有缓存请求指令（`request`的`header`）和缓存响应指令（`response`的`header`）

```
Cache-Control: max-age=20000	// 当前资源在20000秒内都不用再请求了，直接使用缓存
Cache-Control: no-cache		// 使用缓存前，需要验证(协商缓存验证)
Cache-Control: no-store		// 关闭缓存
```



**Expires和Cache-Control的优先级**

如果在`Cache-Control`响应头设置了 `max-age` 或者 `s-maxage` 指令，那么 `Expires` 头会被忽略



三、协商缓存和强制缓存优先级

协商缓存需要发请求跟服务器协商，强制缓存如果生效，根本就不会发请求。所以这个优先级就是：**先判断强制缓存，如果强制缓存生效，直接使用缓存；如果强制缓存失效，再发请求跟服务器协商，看要不要使用缓存**。

---

##### HTTP和HTTPS

一、HTTP、HTTPS

**HTTP**：超文本传输协议，是一种网络通信的规范。特点：

- 明文方式发送内容
- 支持客户-服务器模式
- 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快
- 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记
- 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间
- 无状态：HTTP协议无法根据之前的状态进行本次的请求处理

**HTTPS**：为了解决HTTP的不安全性（明文传输）。为了保证这些隐私数据能加密传输，让`HTTP`运行安全的`SSL/TLS`协议上，即 HTTPS = HTTP + SSL/TLS，通过 `SSL`证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密

**区别**：

- HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全
- HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443
- HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP
- HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高

二、[HTTPS的安全性](https://vue3js.cn/interview/http/HTTPS.html#一、安全特性)

<img src="https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221021091454747.png" alt="image-20221021083844598" style="zoom: 40%;" />

TSL：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。TSL是SSL的更新版本，目前有两个版本：TSL1.2（2008年）、TSL1.3（2018）

SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。版本：SSL1.0（由于安全问题从未公开发布）、SSL2.0（2011年弃用）、SSL3.0（2015年弃用）

SLL的实现这些功能主要依赖于三种手段：

- 对称加密：采用协商的密钥对数据加密（会话密钥）
- 非对称加密：实现身份认证和密钥协商（公钥、私钥）
- 摘要算法：验证信息的完整性（散列函数、哈希函数）
- 数字签名：身份验证（私钥加密，公钥解密）

CA认证的数字证书：认证公钥的安全性（CA公钥、CA私钥）

[数字签名是什么?](https://ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)



三、[TCP/IP协议](https://vue3js.cn/interview/http/TCP_IP.html#一、是什么)

![](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221021091527785.png)



四、DNS(Domain Names System)

1.定义：域名系统，是进行域名和与之相对应的 IP 地址进行转换的服务器

2.DNS查询方式

- 递归查询

<img src="https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221021091800068.png" alt="image-20221021091454747" style="zoom: 50%;" />

- 迭代查询

<img src="https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221021141726095.png" alt="image-20221021091527785" style="zoom:50%;" />

3.域名缓存

- 浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗
- 操作系统缓存：操作系统的缓存其实是用户自己配置的 `hosts` 文件

4.查询过程

![image-20221021091800068](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221021141834481.png)

五、CDN（ Content Delivery Network）

1.定义：内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。简单来讲，CDN就是根据用户位置分配最近的资源。

CDN的逻辑主要分为两步：DNS解析和请求边缘节点

2.CNAME（Canonical Name）：通常称别名指向，CNAME记录必须始终指向另一个域名，永远不要直接指向IP地址。

![image-20221021141726095](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221021141911032.png)

3.[CDN原理](https://juejin.cn/post/6844903890706661389#heading-5)

![image-20221021141834481](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221021144808733.png)

<img src="https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221021144823574.png" alt="image-20221021141911032" style="zoom:50%;" />



六、HTTP1.0、HTTP1.1、HTTP2.0

HTTP1.0

- 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接

HTTP1.1

- 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用
- 在同一个TCP连接里面，客户端可以同时发送多个请求
- 虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着
- 新增了一些请求方法
- 新增了一些请求头和响应头

HTTP2.0

- 采用二进制格式而非文本格式
- 完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行
- 使用报头压缩，降低开销
- 服务器推送



七、UDP和TCP

UDP（User Datagram Protocol），用户数据报协议，是一个简单的**面向数据报的通信协议**，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层

TCP（Transmission Control Protocol），传输控制协议，是一种可靠、**面向字节流的通信协议**，把上面应用层交下来的数据看成无结构的字节流来发送。同时，TCP是一种面向有连接的传输层协议

![image-20221021144808733](https://raw.githubusercontent.com/ethanlamm/notes/image/img/b6cdd800-b393-11eb-ab90-d9ae814b240d.png)

![image-20221021144823574](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221021224751136.png)

两者区别如下表所示：

|          | TCP                              | UDP                            |
| -------- | -------------------------------- | ------------------------------ |
| 可靠性   | 可靠                             | 不可靠                         |
| 连接性   | 面向连接                         | 无连接                         |
| 报文     | 面向字节流                       | 面向报文                       |
| 效率     | 传输效率低                       | 传输效率高                     |
| 双共性   | 全双工                           | 一对一、一对多、多对一、多对多 |
| 流量控制 | 滑动窗口                         | 无                             |
| 拥塞控制 | 慢开始、拥塞避免、快重传、快恢复 | 无                             |
| 传输效率 | 慢                               | 快                             |

两者应用场景如下图：

<img src="https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20221021151258105.png" style="zoom:50%;" />

- TCP 应用场景适用于对效率要求低，对准确性要求高或者要求有链接的场景

- UDP 适用场景为对效率要求高，对准确性要求低的场景



八、地址栏输入 URL 敲下回车后发生了什么?

![image-20221021151258105](https://raw.githubusercontent.com/ethanlamm/notes/image/img/image-20220902210928235.png)



九、[TCP 三次握手与四次挥手](https://xiaolincoding.com/network/3_tcp/tcp_interview.html)

SYN（Synchronize Sequence Numbers）：同步序列编号，是TCP/IP建立连接时使用的握手信号

seq（Sequence Number）：序列号，计算机随机生成，每4ms加1

ISN（Initial Sequence Number）：初始化的序列号，即客户端和服务器首次发送SYN报文时TCP首部所携带的序列号。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）

三次握手（Three-way Handshake）

其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。

四次挥手

TCP断开连接通过四次挥手



![image-20221021224751136](https://raw.githubusercontent.com/ethanlamm/notes/image/img/chrome-capture-2022-8-5.gif)



三次连接通俗解释：

- 服务端调用listen系统命令，进入监听状态，等待客户端的连接。
- 客户端向服务端发送`连接请求报文`，其中TCP标志位里SYN=1，ACK=0，选择一个初始的序号x。
- 服务端收到请求报文，向 客户端 发送`连接确认报文`，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
- 客户端 收到 服务端的连接确认报文后，还要向 服务端 `发出确认`，确认号为 y+1，序号为 x+1。
- 服务端 收到 客户端 的确认后，`连接建立`。



十、SYN攻击

**服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的**，所以服务器容易受到 SYN Flood 攻击。

SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。

常见的防御 SYN 攻击的方法有如下几种：

- 缩短超时（SYN Timeout）时间
- 增加最大半连接数
- 过滤网关防护
- SYN cookies技术



十一、[WebSocket](https://xiaolincoding.com/network/2_http/http_websocket.html#websocket是什么)

- TCP 协议本身是**全双工**的，但我们最常用的 HTTP/1.1，虽然是基于 TCP 的协议，但它是**半双工**的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 WebSocket 协议。
- 在 HTTP/1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用**定时轮询或者长轮询**的方式实现**服务器推送**(comet)的效果。
- 对于客户端和服务端之间需要频繁交互的复杂场景，比如**网页/小程序游戏**、**网页聊天室**，都可以考虑使用 WebSocket 协议。
- WebSocket 和 socket 几乎没有任何关系，只是叫法相似。
- 正因为各个浏览器都支持 HTTP协 议，所以 WebSocket 会先利用HTTP协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 WebSocket 的数据格式进行收发数据。

---

##### 跨域问题

前端：jsonp、vue项目设置代理（打包后无效，.env文件配置）

后端：CORS

